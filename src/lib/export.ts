/**
 * Export utilities for Rune-X
 * Supports TEI-XML, JSON-LD, and other formats for digital humanities workflows
 */

import { Upload, GlyphMatch, Translation, ReconstructionVersion } from '@prisma/client'

interface ExportData {
  upload: Upload & {
    glyphs: (GlyphMatch & {
      glyph: {
        symbol: string
        name?: string
        description?: string
      }
    })[]
    translations: Translation[]
    versions?: ReconstructionVersion[]
  }
}

/**
 * Export to TEI-XML format
 * TEI (Text Encoding Initiative) XML is a standard format for scholarly text encoding
 */
export function exportToTEI(data: ExportData): string {
  const { upload, glyphs, translations } = data.upload
  
  const teiHeader = `<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>${escapeXml(upload.originalName)}</title>
      </titleStmt>
      <publicationStmt>
        <p>Generated by Rune-X</p>
        <date>${new Date().toISOString()}</date>
      </publicationStmt>
      <sourceDesc>
        <p>${upload.provenance || 'Unknown provenance'}</p>
        ${upload.scriptType ? `<p>Script Type: ${escapeXml(upload.scriptType)}</p>` : ''}
        ${upload.imagingMethod ? `<p>Imaging Method: ${escapeXml(upload.imagingMethod)}</p>` : ''}
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>`

  const glyphElements = glyphs
    .sort((a, b) => (a.position || 0) - (b.position || 0))
    .map(glyph => {
      const confidence = (glyph.confidence * 100).toFixed(1)
      const reconstructed = glyph.isReconstructed ? ' reconstructed="true"' : ''
      return `      <g type="glyph" confidence="${confidence}"${reconstructed}>
        <symbol>${escapeXml(glyph.glyph.symbol)}</symbol>
        ${glyph.glyph.name ? `<name>${escapeXml(glyph.glyph.name)}</name>` : ''}
        ${glyph.glyph.description ? `<desc>${escapeXml(glyph.glyph.description)}</desc>` : ''}
        ${glyph.boundingBox ? `<bbox>${escapeXml(glyph.boundingBox)}</bbox>` : ''}
      </g>`
    })
    .join('\n')

  const translationElements = translations
    .map(translation => {
      return `      <translation lang="${escapeXml(translation.language)}" confidence="${(translation.confidence * 100).toFixed(1)}">
        <orig>${escapeXml(translation.originalText)}</orig>
        <trans>${escapeXml(translation.translatedText)}</trans>
        ${translation.context ? `<context>${escapeXml(translation.context)}</context>` : ''}
      </translation>`
    })
    .join('\n')

  const teiFooter = `    </body>
  </text>
</TEI>`

  return teiHeader + '\n' + glyphElements + '\n' + translationElements + '\n' + teiFooter
}

/**
 * Export to JSON-LD format
 * JSON-LD is a standard for linked data, useful for semantic web and digital humanities
 */
export function exportToJSONLD(data: ExportData): string {
  const { upload, glyphs, translations } = data.upload
  
  const jsonLd = {
    '@context': {
      '@vocab': 'https://rune-x.com/vocab/',
      'dc': 'http://purl.org/dc/elements/1.1/',
      'dcterms': 'http://purl.org/dc/terms/',
      'tei': 'http://www.tei-c.org/ns/1.0',
      'schema': 'https://schema.org/'
    },
    '@type': 'AncientInscription',
    '@id': `https://rune-x.com/upload/${upload.id}`,
    'dc:title': upload.originalName,
    'dc:created': upload.createdAt.toISOString(),
    'dcterms:provenance': upload.provenance || null,
    'schema:encodingFormat': upload.imagingMethod || null,
    'tei:scriptType': upload.scriptType || null,
    'rune-x:status': upload.status,
    'rune-x:glyphs': glyphs
      .sort((a, b) => (a.position || 0) - (b.position || 0))
      .map(glyph => ({
        '@type': 'Glyph',
        'rune-x:position': glyph.position,
        'rune-x:symbol': glyph.glyph.symbol,
        'rune-x:name': glyph.glyph.name || null,
        'rune-x:description': glyph.glyph.description || null,
        'rune-x:confidence': glyph.confidence,
        'rune-x:isReconstructed': glyph.isReconstructed,
        'rune-x:boundingBox': glyph.boundingBox ? JSON.parse(glyph.boundingBox) : null,
        'rune-x:strokeCount': glyph.strokeCount || null,
        'rune-x:contourComplexity': glyph.contourComplexity || null
      })),
    'rune-x:translations': translations.map(translation => ({
      '@type': 'Translation',
      'dc:language': translation.language,
      'rune-x:originalText': translation.originalText,
      'rune-x:translatedText': translation.translatedText,
      'rune-x:confidence': translation.confidence,
      'rune-x:context': translation.context || null
    })),
    'rune-x:reconstructionVersions': upload.versions?.map(version => ({
      '@type': 'ReconstructionVersion',
      'rune-x:versionNumber': version.versionNumber,
      'rune-x:confidence': version.confidence,
      'rune-x:method': version.method || null,
      'rune-x:createdAt': version.createdAt.toISOString()
    })) || []
  }

  return JSON.stringify(jsonLd, null, 2)
}

/**
 * Export to CSV format
 */
export function exportToCSV(data: ExportData): string {
  const { upload, glyphs, translations } = data.upload
  
  const rows: string[] = []
  
  // Header
  rows.push('Position,Symbol,Name,Description,Confidence,IsReconstructed,OriginalText,TranslatedText,Language,TranslationConfidence')
  
  // Combine glyphs and translations
  glyphs
    .sort((a, b) => (a.position || 0) - (b.position || 0))
    .forEach(glyph => {
      const translation = translations.find(t => t.glyphId === glyph.glyphId) || translations[0]
      const row = [
        glyph.position?.toString() || '',
        glyph.glyph.symbol,
        glyph.glyph.name || '',
        glyph.glyph.description || '',
        glyph.confidence.toFixed(3),
        glyph.isReconstructed ? 'Yes' : 'No',
        translation?.originalText || '',
        translation?.translatedText || '',
        translation?.language || '',
        translation?.confidence.toFixed(3) || ''
      ]
      rows.push(row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(','))
    })
  
  return rows.join('\n')
}

/**
 * Helper function to escape XML special characters
 */
function escapeXml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
}

/**
 * Get export file extension for a format
 */
export function getExportExtension(format: string): string {
  switch (format) {
    case 'TEI_XML':
      return 'xml'
    case 'JSON_LD':
      return 'jsonld'
    case 'CSV':
      return 'csv'
    case 'PDF':
      return 'pdf'
    case 'IMAGE':
      return 'png'
    default:
      return 'txt'
  }
}

/**
 * Get MIME type for a format
 */
export function getExportMimeType(format: string): string {
  switch (format) {
    case 'TEI_XML':
      return 'application/xml'
    case 'JSON_LD':
      return 'application/ld+json'
    case 'CSV':
      return 'text/csv'
    case 'PDF':
      return 'application/pdf'
    case 'IMAGE':
      return 'image/png'
    default:
      return 'text/plain'
  }
}
